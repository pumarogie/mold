use crate::generators::{Generator, GeneratorConfig};
use crate::types::{NestedType, ObjectType, Schema, SchemaType};
use crate::utils::{is_ts_reserved, sanitize_identifier};
use anyhow::Result;
use std::collections::HashMap;

pub struct TypeScriptGenerator;

impl TypeScriptGenerator {
    pub fn new() -> Self {
        Self
    }

    fn generate_type(
        &self,
        schema_type: &SchemaType,
        indent: &str,
        type_refs: &HashMap<String, String>,
    ) -> String {
        match schema_type {
            SchemaType::String => "string".to_string(),
            SchemaType::Number | SchemaType::Integer => "number".to_string(),
            SchemaType::Boolean => "boolean".to_string(),
            SchemaType::Null => "null".to_string(),
            SchemaType::Any => "unknown".to_string(),
            SchemaType::Array(inner) => {
                let inner_type = self.generate_type(inner, indent, type_refs);
                if matches!(**inner, SchemaType::Union(_)) {
                    format!("({})[]", inner_type)
                } else {
                    format!("{}[]", inner_type)
                }
            }
            SchemaType::Optional(inner) => {
                let inner_type = self.generate_type(inner, indent, type_refs);
                format!("{} | undefined", inner_type)
            }
            SchemaType::Union(types) => {
                let type_strings: Vec<String> = types
                    .iter()
                    .map(|t| self.generate_type(t, indent, type_refs))
                    .collect();
                type_strings.join(" | ")
            }
            SchemaType::Object(obj) => {
                // Check if this object has a type reference
                let obj_key = format!("{:?}", obj);
                if let Some(type_name) = type_refs.get(&obj_key) {
                    type_name.clone()
                } else {
                    self.generate_inline_object(obj, indent, type_refs)
                }
            }
        }
    }

    fn generate_inline_object(
        &self,
        obj: &ObjectType,
        indent: &str,
        type_refs: &HashMap<String, String>,
    ) -> String {
        if obj.fields.is_empty() {
            return "Record<string, unknown>".to_string();
        }

        let mut lines = vec!["{".to_string()];
        for field in &obj.fields {
            let field_name = self.format_field_name(&field.name);
            let field_type =
                self.generate_type(&field.field_type, &format!("{}  ", indent), type_refs);
            let optional = if field.optional { "?" } else { "" };
            lines.push(format!(
                "{}  {}{}: {};",
                indent, field_name, optional, field_type
            ));
        }
        lines.push(format!("{}}}", indent));
        lines.join("\n")
    }

    fn generate_interface(
        &self,
        name: &str,
        obj: &ObjectType,
        indent: &str,
        type_refs: &HashMap<String, String>,
    ) -> String {
        let mut lines = vec![format!("interface {} {{", name)];

        for field in &obj.fields {
            let field_name = self.format_field_name(&field.name);
            let field_type = self.generate_type(&field.field_type, indent, type_refs);
            let optional = if field.optional { "?" } else { "" };
            lines.push(format!("{}{}{}: {};", indent, field_name, optional, field_type));
        }

        lines.push("}".to_string());
        lines.join("\n")
    }

    fn format_field_name(&self, name: &str) -> String {
        let sanitized = sanitize_identifier(name);
        if name != sanitized || is_ts_reserved(name) || name.contains('-') || name.contains(' ') {
            format!("\"{}\"", name)
        } else {
            name.to_string()
        }
    }

    fn build_type_refs(&self, nested_types: &[NestedType]) -> HashMap<String, String> {
        let mut refs = HashMap::new();
        for nt in nested_types {
            let key = format!("{:?}", nt.object);
            refs.insert(key, nt.name.clone());
        }
        refs
    }
}

impl Default for TypeScriptGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl Generator for TypeScriptGenerator {
    fn generate(&self, schema: &Schema, config: &GeneratorConfig) -> Result<String> {
        let mut output = vec!["// Generated by mold".to_string(), String::new()];

        // Build type reference map
        let type_refs = if config.flat_mode {
            HashMap::new()
        } else {
            self.build_type_refs(&schema.nested_types)
        };

        // Generate nested types first (if not flat mode)
        if !config.flat_mode && !schema.nested_types.is_empty() {
            // Output in reverse order (deepest nested first)
            for nt in schema.nested_types.iter().rev() {
                output.push(self.generate_interface(&nt.name, &nt.object, &config.indent, &type_refs));
                output.push(String::new());
            }
        }

        // Generate root interface
        if let SchemaType::Object(obj) = &schema.root_type {
            output.push(self.generate_interface(&schema.name, obj, &config.indent, &type_refs));
        }

        Ok(output.join("\n"))
    }

    fn file_extension(&self) -> &'static str {
        "ts"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::Field;

    #[test]
    fn test_generate_simple_interface() {
        let gen = TypeScriptGenerator::new();
        let obj = ObjectType::new(vec![
            Field::new("id", SchemaType::Integer),
            Field::new("name", SchemaType::String),
            Field::new("active", SchemaType::Boolean),
        ]);
        let schema = Schema::new("User", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("interface User"));
        assert!(output.contains("id: number"));
        assert!(output.contains("name: string"));
        assert!(output.contains("active: boolean"));
    }

    #[test]
    fn test_generate_array_type() {
        let gen = TypeScriptGenerator::new();
        let obj = ObjectType::new(vec![Field::new(
            "tags",
            SchemaType::Array(Box::new(SchemaType::String)),
        )]);
        let schema = Schema::new("Test", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("tags: string[]"));
    }

    #[test]
    fn test_generate_union_type() {
        let gen = TypeScriptGenerator::new();
        let obj = ObjectType::new(vec![Field::new(
            "value",
            SchemaType::Union(vec![SchemaType::String, SchemaType::Integer]),
        )]);
        let schema = Schema::new("Test", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("value: string | number"));
    }

    #[test]
    fn test_empty_object() {
        let gen = TypeScriptGenerator::new();
        let obj = ObjectType::new(vec![Field::new(
            "metadata",
            SchemaType::Object(ObjectType::empty()),
        )]);
        let schema = Schema::new("Test", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("Record<string, unknown>"));
    }
}
