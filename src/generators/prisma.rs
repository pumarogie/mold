use crate::generators::{Generator, GeneratorConfig};
use crate::types::{NestedType, ObjectType, Schema, SchemaType};
use crate::utils::{is_prisma_reserved, sanitize_identifier, to_pascal_case};
use anyhow::Result;

pub struct PrismaGenerator;

impl PrismaGenerator {
    pub fn new() -> Self {
        Self
    }

    fn generate_prisma_type(&self, schema_type: &SchemaType) -> Option<String> {
        match schema_type {
            SchemaType::String => Some("String".to_string()),
            SchemaType::Number => Some("Float".to_string()),
            SchemaType::Integer => Some("Int".to_string()),
            SchemaType::Boolean => Some("Boolean".to_string()),
            SchemaType::Array(inner) => {
                // Prisma only supports arrays of scalar types
                match inner.as_ref() {
                    SchemaType::String => Some("String[]".to_string()),
                    SchemaType::Integer => Some("Int[]".to_string()),
                    SchemaType::Number => Some("Float[]".to_string()),
                    SchemaType::Boolean => Some("Boolean[]".to_string()),
                    _ => None, // Arrays of objects need relations
                }
            }
            SchemaType::Null => None, // Prisma doesn't have null type
            SchemaType::Optional(inner) => {
                self.generate_prisma_type(inner).map(|t| format!("{}?", t))
            }
            SchemaType::Any | SchemaType::Union(_) => Some("Json".to_string()), // Use Json for complex types
            SchemaType::Object(_) => None, // Objects need to be separate models
        }
    }

    fn generate_model(&self, name: &str, obj: &ObjectType, indent: &str) -> String {
        let model_name = self.format_model_name(name);
        let mut lines = vec![format!("model {} {{", model_name)];

        // Add id field
        lines.push(format!("{}id Int @id @default(autoincrement())", indent));

        // Add regular fields
        for field in &obj.fields {
            if let Some(field_str) = self.generate_field(field, indent) {
                lines.push(field_str);
            }
        }

        lines.push("}".to_string());
        lines.join("\n")
    }

    fn generate_field(&self, field: &crate::types::Field, indent: &str) -> Option<String> {
        let field_name = self.format_field_name(&field.name);

        // Handle object types (need relations)
        if let SchemaType::Object(_) = &field.field_type {
            // Skip - these need to be handled as relations
            return None;
        }

        let prisma_type = self.generate_prisma_type(&field.field_type)?;
        let optional = if field.optional { "?" } else { "" };

        Some(format!(
            "{}{} {}{}",
            indent,
            field_name,
            prisma_type,
            if optional.is_empty() { "" } else { optional }
        ))
    }

    fn format_field_name(&self, name: &str) -> String {
        let sanitized = sanitize_identifier(name);
        // Prisma field names must be valid identifiers
        if is_prisma_reserved(&sanitized) {
            format!("{}_", sanitized)
        } else {
            sanitized
        }
    }

    fn format_model_name(&self, name: &str) -> String {
        let pascal = to_pascal_case(name);
        if is_prisma_reserved(&pascal) {
            format!("{}Model", pascal)
        } else {
            pascal
        }
    }

    fn generate_nested_models(&self, nested_types: &[NestedType], indent: &str) -> Vec<String> {
        // Output deepest nested first (reversed)
        nested_types
            .iter()
            .rev()
            .map(|nt| self.generate_model(&nt.name, &nt.object, indent))
            .collect()
    }
}

impl Default for PrismaGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl Generator for PrismaGenerator {
    fn generate(&self, schema: &Schema, config: &GeneratorConfig) -> Result<String> {
        let mut output = vec!["// Generated by mold".to_string(), String::new()];

        // Generate nested models first (if not flat mode)
        if !config.flat_mode && !schema.nested_types.is_empty() {
            let nested = self.generate_nested_models(&schema.nested_types, &config.indent);
            for model in nested {
                output.push(model);
                output.push(String::new());
            }
        }

        // Generate root model
        if let SchemaType::Object(obj) = &schema.root_type {
            output.push(self.generate_model(&schema.name, obj, &config.indent));
        }

        Ok(output.join("\n"))
    }

    fn file_extension(&self) -> &'static str {
        "prisma"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::Field;

    #[test]
    fn test_generate_simple_model() {
        let gen = PrismaGenerator::new();
        let obj = ObjectType::new(vec![
            Field::new("name", SchemaType::String),
            Field::new("age", SchemaType::Integer),
            Field::new("active", SchemaType::Boolean),
        ]);
        let schema = Schema::new("User", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("model User {"));
        assert!(output.contains("id Int @id @default(autoincrement())"));
        assert!(output.contains("name String"));
        assert!(output.contains("age Int"));
        assert!(output.contains("active Boolean"));
    }

    #[test]
    fn test_generate_array_field() {
        let gen = PrismaGenerator::new();
        let obj = ObjectType::new(vec![Field::new(
            "tags",
            SchemaType::Array(Box::new(SchemaType::String)),
        )]);
        let schema = Schema::new("Post", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("tags String[]"));
    }

    #[test]
    fn test_generate_float_field() {
        let gen = PrismaGenerator::new();
        let obj = ObjectType::new(vec![Field::new("price", SchemaType::Number)]);
        let schema = Schema::new("Product", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("price Float"));
    }

    #[test]
    fn test_reserved_word_handling() {
        let gen = PrismaGenerator::new();
        let obj = ObjectType::new(vec![Field::new("model", SchemaType::String)]);
        let schema = Schema::new("Test", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        // Should rename the reserved field
        assert!(output.contains("model_ String"));
    }
}
