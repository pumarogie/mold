mod relations;
mod types;

use crate::generators::{Generator, GeneratorConfig};
use crate::types::{NestedType, ObjectType, Schema, SchemaType};
use anyhow::Result;
use std::collections::HashMap;

use relations::{format_model_name, generate_field};

pub struct PrismaGenerator;

impl PrismaGenerator {
    pub fn new() -> Self {
        Self
    }

    fn generate_model(
        &self,
        name: &str,
        obj: &ObjectType,
        indent: &str,
        type_refs: &HashMap<String, String>,
        generate_relations: bool,
    ) -> String {
        let model_name = format_model_name(name);
        let mut lines = vec![format!("model {} {{", model_name)];

        lines.push(format!("{}id Int @id @default(autoincrement())", indent));

        for field in &obj.fields {
            if let Some(field_lines) = generate_field(field, indent, type_refs, generate_relations) {
                for line in field_lines {
                    lines.push(line);
                }
            }
        }

        lines.push("}".to_string());
        lines.join("\n")
    }

    fn build_type_refs(&self, nested_types: &[NestedType]) -> HashMap<String, String> {
        let mut refs = HashMap::new();
        for nt in nested_types {
            let key = format!("{:?}", nt.object);
            refs.insert(key, nt.name.clone());
        }
        refs
    }

    fn generate_nested_models(
        &self,
        nested_types: &[NestedType],
        indent: &str,
        type_refs: &HashMap<String, String>,
        generate_relations: bool,
    ) -> Vec<String> {
        nested_types
            .iter()
            .rev()
            .map(|nt| self.generate_model(&nt.name, &nt.object, indent, type_refs, generate_relations))
            .collect()
    }
}

impl Default for PrismaGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl Generator for PrismaGenerator {
    fn generate(&self, schema: &Schema, config: &GeneratorConfig) -> Result<String> {
        let mut output = vec!["// Generated by mold".to_string(), String::new()];

        let type_refs = if config.flat_mode {
            HashMap::new()
        } else {
            self.build_type_refs(&schema.nested_types)
        };

        if !config.flat_mode && !schema.nested_types.is_empty() {
            let nested = self.generate_nested_models(
                &schema.nested_types,
                &config.indent,
                &type_refs,
                config.prisma_generate_relations,
            );
            for model in nested {
                output.push(model);
                output.push(String::new());
            }
        }

        if let SchemaType::Object(obj) = &schema.root_type {
            output.push(self.generate_model(
                &schema.name,
                obj,
                &config.indent,
                &type_refs,
                config.prisma_generate_relations,
            ));
        }

        Ok(output.join("\n"))
    }

    fn file_extension(&self) -> &'static str {
        "prisma"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::Field;

    #[test]
    fn test_generate_simple_model() {
        let gen = PrismaGenerator::new();
        let obj = ObjectType::new(vec![
            Field::new("name", SchemaType::String),
            Field::new("age", SchemaType::Integer),
            Field::new("active", SchemaType::Boolean),
        ]);
        let schema = Schema::new("User", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("model User {"));
        assert!(output.contains("id Int @id @default(autoincrement())"));
        assert!(output.contains("name String"));
        assert!(output.contains("age Int"));
        assert!(output.contains("active Boolean"));
    }

    #[test]
    fn test_generate_array_field() {
        let gen = PrismaGenerator::new();
        let obj = ObjectType::new(vec![Field::new(
            "tags",
            SchemaType::Array(Box::new(SchemaType::String)),
        )]);
        let schema = Schema::new("Post", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("tags String[]"));
    }

    #[test]
    fn test_generate_float_field() {
        let gen = PrismaGenerator::new();
        let obj = ObjectType::new(vec![Field::new("price", SchemaType::Number)]);
        let schema = Schema::new("Product", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("price Float"));
    }

    #[test]
    fn test_reserved_word_handling() {
        let gen = PrismaGenerator::new();
        let obj = ObjectType::new(vec![Field::new("model", SchemaType::String)]);
        let schema = Schema::new("Test", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("model_ String"));
    }
}
