mod types;

use crate::generators::{Generator, GeneratorConfig};
use crate::types::{NestedType, ObjectType, Schema, SchemaType};
use anyhow::Result;
use std::collections::HashMap;

use types::{format_field_name, generate_type};

pub struct TypeScriptGenerator;

impl TypeScriptGenerator {
    pub fn new() -> Self {
        Self
    }

    fn generate_interface(
        &self,
        name: &str,
        obj: &ObjectType,
        indent: &str,
        type_refs: &HashMap<String, String>,
        config: &GeneratorConfig,
    ) -> String {
        let export_keyword = if config.ts_export_interfaces {
            "export "
        } else {
            ""
        };
        let mut lines = vec![format!("{}interface {} {{", export_keyword, name)];

        for field in &obj.fields {
            let field_name = format_field_name(&field.name);
            let field_type = generate_type(&field.field_type, indent, type_refs);
            let optional = if field.optional { "?" } else { "" };
            let readonly = if config.ts_readonly_fields || field.metadata.is_readonly {
                "readonly "
            } else {
                ""
            };
            lines.push(format!(
                "{}{}{}{}: {};",
                indent, readonly, field_name, optional, field_type
            ));
        }

        lines.push("}".to_string());
        lines.join("\n")
    }

    fn build_type_refs(&self, nested_types: &[NestedType]) -> HashMap<String, String> {
        let mut refs = HashMap::new();
        for nt in nested_types {
            let key = format!("{:?}", nt.object);
            refs.insert(key, nt.name.clone());
        }
        refs
    }
}

impl Default for TypeScriptGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl Generator for TypeScriptGenerator {
    fn generate(&self, schema: &Schema, config: &GeneratorConfig) -> Result<String> {
        let mut output = vec!["// Generated by mold".to_string(), String::new()];

        let type_refs = if config.flat_mode {
            HashMap::new()
        } else {
            self.build_type_refs(&schema.nested_types)
        };

        if !config.flat_mode && !schema.nested_types.is_empty() {
            for nt in schema.nested_types.iter().rev() {
                output.push(self.generate_interface(
                    &nt.name,
                    &nt.object,
                    &config.indent,
                    &type_refs,
                    config,
                ));
                output.push(String::new());
            }
        }

        if let SchemaType::Object(obj) = &schema.root_type {
            output.push(self.generate_interface(
                &schema.name,
                obj,
                &config.indent,
                &type_refs,
                config,
            ));
        }

        Ok(output.join("\n"))
    }

    fn file_extension(&self) -> &'static str {
        "ts"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::types::Field;

    #[test]
    fn test_generate_simple_interface() {
        let gen = TypeScriptGenerator::new();
        let obj = ObjectType::new(vec![
            Field::new("id", SchemaType::Integer),
            Field::new("name", SchemaType::String),
            Field::new("active", SchemaType::Boolean),
        ]);
        let schema = Schema::new("User", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("interface User"));
        assert!(output.contains("id: number"));
        assert!(output.contains("name: string"));
        assert!(output.contains("active: boolean"));
    }

    #[test]
    fn test_generate_array_type() {
        let gen = TypeScriptGenerator::new();
        let obj = ObjectType::new(vec![Field::new(
            "tags",
            SchemaType::Array(Box::new(SchemaType::String)),
        )]);
        let schema = Schema::new("Test", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("tags: string[]"));
    }

    #[test]
    fn test_generate_union_type() {
        let gen = TypeScriptGenerator::new();
        let obj = ObjectType::new(vec![Field::new(
            "value",
            SchemaType::Union(vec![SchemaType::String, SchemaType::Integer]),
        )]);
        let schema = Schema::new("Test", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("value: number | string"));
    }

    #[test]
    fn test_empty_object() {
        let gen = TypeScriptGenerator::new();
        let obj = ObjectType::new(vec![Field::new(
            "metadata",
            SchemaType::Object(ObjectType::empty()),
        )]);
        let schema = Schema::new("Test", SchemaType::Object(obj));
        let config = GeneratorConfig::default();

        let output = gen.generate(&schema, &config).unwrap();

        assert!(output.contains("Record<string, unknown>"));
    }
}
